package course2.week4;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer;/*    In this problem your goal is to implement the Rabin–Karp’s algorithm for searching the given pattern in the given text. */public class HashSubstring {    private static int PRIME = 1000000007;    private static int MULTIPLIER = 31;    public static void main(String[] args) throws IOException {        printOccurrences(getOccurrences(readInput()));    }    private static List<Integer> getOccurrences(Data data) {        int patternHash = hash(data.pattern);        int patternLength = data.pattern.length();        long[] hashes = computeHashes(data.text, patternLength);        List<Integer> occurrences = new ArrayList<>();        for (int i = 0; i <= data.text.length() - patternLength; i++) {            if (patternHash != hashes[i])                continue;            if (data.text.substring(i, i + patternLength).equals(data.pattern))                occurrences.add(i);        }        return occurrences;    }    private static long[] computeHashes(String text, int patternLength) {        int textLength = text.length();        String lastSubstring = text.substring(textLength - patternLength, textLength);        long[] result = new long[textLength - patternLength + 1];        result[result.length - 1] = hash(lastSubstring);        long multiplierInPowerPatternLength = getMultiplierInPowerPatternLengthModPrime(patternLength);        for (int i = result.length - 2; i >= 0; i--) {            long lastCharacter = multiplierInPowerPatternLength * text.charAt(i + patternLength);            char firstCharacter = text.charAt(i);            long hash = (MULTIPLIER * result[i + 1] + firstCharacter - lastCharacter) % PRIME;            if (hash < 0) hash += PRIME;            result[i] = hash;        }        return result;    }    private static int hash(String string) {        long hash = 0;        for (int i = string.length() - 1; i >= 0; i--)            hash = (hash * MULTIPLIER + string.charAt(i)) % PRIME;        return (int) hash;    }    private static long getMultiplierInPowerPatternLengthModPrime(int patternLength) {        long result = 1;        long base = MULTIPLIER;        while (patternLength > 0) {            if (patternLength % 2 == 1) {                result = (result * base) % PRIME; // multiplying with base            }            base = (base * base) % PRIME; // squaring the base            patternLength /= 2;        }        return result % PRIME;    }    private static Data readInput() throws IOException {        FastScanner in = new FastScanner();        String pattern = in.next();        String text = in.next();        return new Data(pattern, text);    }    private static void printOccurrences(List<Integer> occurrences) {        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));        for (Integer integer : occurrences) {            out.print(integer);            out.print(" ");        }        out.close();    }    static class Data {        String pattern;        String text;        Data(String pattern, String text) {            this.pattern = pattern;            this.text = text;        }    }    static class FastScanner {        private BufferedReader reader;        private StringTokenizer tokenizer;        FastScanner() {            reader = new BufferedReader(new InputStreamReader(System.in));            tokenizer = null;        }        public String next() throws IOException {            while (tokenizer == null || !tokenizer.hasMoreTokens()) {                tokenizer = new StringTokenizer(reader.readLine());            }            return tokenizer.nextToken();        }        public int nextInt() throws IOException {            return Integer.parseInt(next());        }    }}